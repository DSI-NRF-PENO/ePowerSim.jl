# (C) 2025 Power, Energy, Networks and Optimisation Research Group, Unisa, authors and contributors (see AUTHORS file)
# Licensed under GNU GPL v3 (see LICENSE file)

# AA Yusuff : yusufaa@unisa.ac.za

# Sauer: section 6.10:  pg 135 - 136, 6.242 - 6.247


#####################################################
# ---------------------------------------------------
# States symbols, dictionaries and functions
# ---------------------------------------------------
#####################################################


#---------------------------------------------------
# components states formulation
#---------------------------------------------------

"""
Creation of a dynamic device requires, specification of its
state variables and its sybolic name e.g:

`:avr_t1_cb_sauer` is a sybolic name of a type of avr,
and its states variable are specified as
`Symbol[ :vr1,  :vr2, :vf_tilade ]`. These information
are subsequently added to the appropriate lists in component
state symbols library. In the case of avrs, these lists
are `avrs_type_names` and `avrs_type_state_syms_list` respectively. 

"""

#--------------------------------------
# state symbols
#--------------------------------------


function create_gens_state_syms_lib(
    ; type_file = gens_state_syms_lib_file_json )
    
    #--------------------------------------
     
    gen_state_syms =
        Symbol[:δ, :ω,  :ed_dash, :eq_dash ]

    #--------------------------------------
    
    all_gens_subtypes_syms =
        Symbol.(subtypes(SdGen))

    non_dyn_gens_type =
        [:Infinite_bus,
         :Infinite_cb_bus,
         :SM_2axis_cb_inf_bus]

    gens_type_names =
        [ a_type
          for a_type in
              all_gens_subtypes_syms
              if a_type ∉ non_dyn_gens_type  ]
    
    
    # gens_type_names =
    #     [:SM_2axis_cb_v6,
    #      :SC_2axis_cb_v6]

    #--------------------------------------

    dict_gens_type_state_syms =
        Dict{Symbol, Vector{Symbol}}(
        a_sym => gen_state_syms
        for a_sym in gens_type_names )


    json_dict_gens_type_state_syms =
        JSON.json(dict_gens_type_state_syms)

    #--------------------------------------
    # write
    #--------------------------------------

    open( type_file, "w") do io
        # JSON3.write(io, json_dict_gov_nt_params)
        JSON3.pretty(io, json_dict_gens_type_state_syms)
    end

    
end


function create_avrs_state_syms_lib(
    ; type_file = avr_state_syms_lib_file_json )
    
    #--------------------------------------

    "avr_tx stands for avr_t0 or avr_t1"
    avr_tx_state_syms =
        Symbol[:vm, :vr1, :vr2, :vf_tilade]

    sauer_avr_state_syms =
        Symbol[ :vr1,  :vr2, :vf_tilade ]

    #--------------------------------------

    avrs_type_state_syms_list =
        [avr_tx_state_syms,
         avr_tx_state_syms,
         sauer_avr_state_syms ]
    
    avrs_type_names =
        [:avr_t0_cb,
         :avr_t1_cb,
         :avr_t1_cb_sauer]
    
    #--------------------------------------

    dict_avrs_type_state_syms =
        Dict{Symbol, Vector{Symbol}}(
            a_sym => state_syms
            for (a_sym, state_syms) in
                zip(avrs_type_names,
                    avrs_type_state_syms_list))


    json_dict_avrs_type_state_syms =
        JSON.json( dict_avrs_type_state_syms )

    #--------------------------------------
    # write
    #--------------------------------------

    open( type_file, "w") do io
        JSON3.pretty(
            io,
            json_dict_avrs_type_state_syms)
    end

    
end


function create_govs_state_syms_lib(
    ; type_file = gov_state_syms_lib_file_json )
    
    #--------------------------------------


    gov_sauer_or_ieee_tgov1_state_syms =
        Symbol[ :xg1, :xg2]

    "gov_tx stands for gov_t0 or gov_t1"
    
    gov_tx_state_syms = Symbol[ :xg1, :xg2, :xg3 ]

    no_gov = Symbol[:nothing]
    
    #--------------------------------------

    govs_type_state_syms_list =
        [gov_sauer_or_ieee_tgov1_state_syms,
         gov_sauer_or_ieee_tgov1_state_syms,
         gov_tx_state_syms,
         gov_tx_state_syms,
         no_gov]
    
    govs_type_names =
        [:gov_ieee_tgov1_cb,
         :gov_t1_cb_sauer,
         :gov_t0_cb,
         :gov_t1_cb,
         :nothing]
    
    #--------------------------------------

    dict_govs_type_state_syms =
        Dict{Symbol, Vector{Symbol}}(
            a_sym => state_syms
            for (a_sym, state_syms) in
                zip(govs_type_names,
                    govs_type_state_syms_list))


    json_dict_govs_type_state_syms =
        JSON.json( dict_govs_type_state_syms )

    #--------------------------------------
    # write
    #--------------------------------------

    open( type_file, "w") do io
        JSON3.pretty(
            io,
            json_dict_govs_type_state_syms)
    end

    
end



function create_states_syms_lib(
    ; components_libs_dir =
        nothing)

    #--------------------------------------

    # if components_libs_dir == nothing
        
    #     components_libs_dir =
    #         joinpath(@__DIR__,"..","..","src",
    #                  "components-lib")
    # else
    #     components_libs_dir = components_libs_dir
    # end
    
    if (components_libs_dir == "") || (
        components_libs_dir == nothing)

        package_dir = pkgdir(ePowerSim)

        src_dir =
            joinpath( package_dir, "src")
        
        components_libs_dir =
            joinpath(
                src_dir,
                "components_lib_dir")

    end
    
    gens_states_syms_lib_file =
        joinpath(components_libs_dir,
                 "states-syms",
                 "gens",
                 "gens_type_states_syms.json")

    create_gens_state_syms_lib(
        ; type_file =
            gens_states_syms_lib_file )

    
    govs_states_syms_lib_file =
        joinpath(components_libs_dir,
                 "states-syms",
                 "govs",
                 "govs_type_states_syms.json")

    
    create_govs_state_syms_lib(
    ; type_file = govs_states_syms_lib_file )

    
    avrs_states_syms_lib_file =
        joinpath(components_libs_dir,
                 "states-syms",
                 "avrs",
                 "avrs_type_states_syms.json")

    create_avrs_state_syms_lib(
        ; type_file = avrs_states_syms_lib_file )
        
    #--------------------------------------

    return nothing
end



function get_gens_govs_avrs_dict_states_syms_from_lib(
    ; components_libs_dir =
        nothing)

    #--------------------------------------

    # if components_libs_dir == nothing
        
    #     components_libs_dir =
    #         joinpath(@__DIR__,"..","..","src",
    #                  "components-lib")
    # else
    #     components_libs_dir = components_libs_dir
    # end
    
    if (components_libs_dir == "") || (
        components_libs_dir == nothing)

        package_dir = pkgdir(ePowerSim)

        src_dir =
            joinpath( package_dir, "src")
        
        components_libs_dir =
            joinpath(
                src_dir,
                "components_lib_dir")

    end
    
    gens_states_syms_lib_file =
        joinpath(components_libs_dir,
                 "states-syms",
                 "gens",
                 "gens_type_states_syms.json")

    create_gens_state_syms_lib(
        ; type_file =
            gens_states_syms_lib_file )

    
    govs_states_syms_lib_file =
        joinpath(components_libs_dir,
                 "states-syms",
                 "govs",
                 "govs_type_states_syms.json")

    #--------------------------------------
    
    dict_gens_states_syms =
        get_dict_states_syms_from_json_lib_file(
        gens_states_syms_lib_file)

    
    dict_avrs_states_syms =
        get_dict_states_syms_from_json_lib_file(
        avrs_states_syms_lib_file)

    
    dict_govs_states_syms =
        get_dict_states_syms_from_json_lib_file(
            govs_states_syms_lib_file)

    
    return (;dict_gens_states_syms,
             dict_avrs_states_syms,
             dict_govs_states_syms)
    
end


#---------------------------------------------------
#---------------------------------------------------
# state variable, symbols, dict and related functions 
#---------------------------------------------------
#---------------------------------------------------

"""
`get_dict_states_syms_from_json_lib_file`

This function converts values read from
`json_states_syms_lib_file` to symbolds

"""
function get_dict_states_syms_from_json_lib_file(
    json_states_syms_lib_file)
    
    return Dict{Symbol, Vector{Symbol}}(
        a_key => Symbol.(list_states_strings) 
        for (a_key, list_states_strings)  in 
            JSON3.read(
                json_states_syms_lib_file))

    
    # return Dict{Symbol, Vector{Symbol}}(
    #     a_key => Symbol.(list_states_strings) 
    #     for (a_key, list_states_strings)  in
    #         convert(Dict{Symbol, Vector{String}},
    #          JSON3.read(json_states_syms_lib_file)))
    
    
end

"""
`get_gens_govs_avrs_types_by_json`

This function selects :gen, :gov, :avr as a tuple
from  :components_type property of a plant.

:components_type property of a plant contains other
properties such as :loc_load
"""
function get_gens_govs_avrs_types_by_json(
    plant_generators_data_from_json )
    
    # namedtuple_nested_selection
    # get_components_properties_by_json


    return  [ NamedTupleTools.select(
            getproperty(
                a_item,
                :components_type),
            (:gen, :gov, :avr))
              for a_item in
                  plant_generators_data_from_json ]


end

"""
`get_gens_govs_avrs_states_syms_by_json`

This function retrives states variables symbols for
different types of gens, govs, and avrs from the library
of state symbols.

This information is stored in :

 components_libs_dir
      states-syms
           gens
           govs
           avrs
 
"""
function get_gens_govs_avrs_states_syms_by_json(
    net_data_by_components_file;
    components_libs_dir =
        components_libs_dir )

    
    if (components_libs_dir == "") || (
        components_libs_dir == nothing)

        package_dir = pkgdir(ePowerSim)

        src_dir =
            joinpath( package_dir, "src")
        
        components_libs_dir =
            joinpath(
                src_dir,
                "components_lib_dir")

    end
    
    plant_generators_data_from_json =
        NamedTupleTools.select(
            get_net_data_by_components_from_json_file(
                net_data_by_components_file;
                in_components_type_sym =
                    false ),
            (:plant_generators_data_from_json))

    
    gens_states_syms_lib_file =
        joinpath(components_libs_dir,
                 "states-syms",
                 "gens",
                 "gens_type_states_syms.json")

    
    govs_states_syms_lib_file =
        joinpath(components_libs_dir,
                 "states-syms",
                 "govs",
                 "govs_type_states_syms.json")

    
    avrs_states_syms_lib_file =
        joinpath(components_libs_dir,
                 "states-syms",
                 "avrs",
                 "avrs_type_states_syms.json")

    #--------------------------------------
    
    dict_gens_states_syms =
        get_dict_states_syms_from_json_lib_file(
            gens_states_syms_lib_file )
        
    dict_govs_states_syms =
        get_dict_states_syms_from_json_lib_file(
                govs_states_syms_lib_file )
    
    dict_avrs_states_syms =
        get_dict_states_syms_from_json_lib_file(
           avrs_states_syms_lib_file )

    #--------------------------------------
    
    a_case_list_gens_govs_avrs_types =
        get_gens_govs_avrs_types_by_json(
            plant_generators_data_from_json )

    # This section uses dictionrary to get gens, govs and
    # avrs states symbols


    return ( gens_govs_avrs_states_syms =
        [(gen = dict_gens_states_syms[
            Symbol(an_item.gen)],
             gov = dict_govs_states_syms[
                 Symbol(an_item.gov)],
             avr = dict_avrs_states_syms[
                 Symbol(an_item.avr)] )
        for an_item in
            a_case_list_gens_govs_avrs_types ],
             gens_govs_avrs_types =
                 a_case_list_gens_govs_avrs_types )
        
end



#---------------------------------------------------
# utility functions for dictionaries functions
# of comp init,  dynamic or output functions
#---------------------------------------------------

"""
This function converts a list of functions into
a dictionaly of functions. A key in the dictionary is a
type of a model of component, and the value is a specific function that is applicable to the component.
"""
function get_dict_types_dyn_or_output_func(
    types_func)

    nameof_type_func =
        String.(nameof.(types_func))
    
    types_sym_name =
        Symbol.( String.( second.(
            map( (x) -> split(x, "__"),
                 nameof_type_func ))))

    return Dict{Symbol, Function}(
        type_sym_name => type_func
        for (type_sym_name, type_func) in
            zip(types_sym_name,
                types_func ))
        
end


function get_dict_types_dyn_or_output_func(
    types_func,
    dae_or_ode_type)

    nameof_type_func =
        String.(nameof.(types_func))

    
    fun_model_types =
        Symbol.( String.( first.(
            map( (x) -> split(x, "_"),
                 nameof_type_func ))))

    @assert allequal(fun_model_types)
    
    @assert fun_model_types[1] == Symbol(dae_or_ode_type)
    
    
    types_sym_name =
        Symbol.( String.( second.(
            map( (x) -> split(x, "__"),
                 nameof_type_func ))))

    return  Dict{Symbol, Function}(
                type_sym_name => type_func
                for (type_sym_name, type_func) in
                    zip(types_sym_name,
                        types_func ))
    
        
end


"""
This function return a singleton namedtuple.
The property of the namedtuple is the type of
modelling, which could either be :ode or :dae,
while the property value is a dictionary of
component models and their specific associated
functions.
"""
function get_a_namedtuple_dict_types_dyn_or_output_func(
    types_func, dae_or_ode_type)

    nameof_type_func =
        String.(nameof.(types_func))

    
    fun_model_types =
        Symbol.( String.( first.(
            map( (x) -> split(x, "_"),
                 nameof_type_func ))))

    @assert allequal(fun_model_types)
    
    @assert fun_model_types[1] == Symbol(dae_or_ode_type)
    
    
    types_sym_name =
        Symbol.( String.( second.(
            map( (x) -> split(x, "__"),
                 nameof_type_func ))))

    dict_comp_fun_types = Dict{Symbol, Function}(
                type_sym_name => type_func
                for (type_sym_name, type_func) in
                    zip(types_sym_name,
                        types_func ))

    return namedtuple(
        Dict{Symbol, Dict{Symbol, Function}}(
            dae_or_ode_type => dict_comp_fun_types) )
        
end


"""
This function return a namedtuple of dictionaries
for ode and dae functions.

"""
function get_namedtuple_dict_types_dyn_or_output_func(
    ode_types_func,
    dae_types_func;
    ode_type = :ode,
    dae_type = :dae )

    ode_dict_types =
        get_dict_types_dyn_or_output_func(
            ode_types_func,
            ode_type)

    dae_dict_types =
        get_dict_types_dyn_or_output_func(
            dae_types_func,
            dae_type )

    namedtuple_dict_types =
        namedtuple(
            Dict{Symbol, Dict{Symbol, Function}}(
                ode_type => ode_dict_types,
                dae_type => dae_dict_types ) )

    return namedtuple_dict_types
        
end


function get_dyn_or_output_func(
    list_types_syms,
    dict_types_dyn_or_output_func)

    return Function[
        dict_types_dyn_or_output_func[
            type_sym]
        for type_sym in
            list_types_syms ]
        
end


function get_dyn_or_output_func(
    list_types_syms,
    namedtuple_dict_types_dyn_or_output_func,
    dae_or_ode_type )

    dict_types_dyn_or_output_func =
        getproperty(
            namedtuple_dict_types_dyn_or_output_func,
            dae_or_ode_type )

    return Function[
        dict_types_dyn_or_output_func[
            type_sym]
        for type_sym in
            list_types_syms ]
        
end



#---------------------------------------------------
# dictionaries functions  of comp init,
# dynamic or output functions
#---------------------------------------------------

function get_gens_callback_paras_func(
    list_types_syms)

    return get_dyn_or_output_func(
        list_types_syms,
        get_dict_gens_type_callback_paras_func())
        
end


function get_gens_init_func(
    list_types_syms)

    return get_dyn_or_output_func(
        list_types_syms,
        get_dict_gens_type_init_func())
        
end


function get_gens_output_func(
    list_types_syms)

    return get_dyn_or_output_func(
        list_types_syms,
        get_dict_gens_type_output_func())
        
end


function get_gens_dyn_func(
    list_types_syms)

    return get_dyn_or_output_func(
        list_types_syms,
        get_dict_gens_type_dyn_func())
        
end


function get_gens_dyn_func(
    list_types_syms,
    dae_or_ode_type)

    return get_dyn_or_output_func(
        list_types_syms,
        get_dict_gens_type_dyn_func(
            dae_or_ode_type))
        
end


#---------------------------------------------------


function get_govs_callback_paras_func(
    list_types_syms)

    return get_dyn_or_output_func(
        list_types_syms,
        get_dict_govs_type_callback_paras_func())
        
end


function get_govs_init_func(
    list_types_syms)

    return get_dyn_or_output_func(
        list_types_syms,
        get_dict_govs_type_init_func() )
        
end


function get_govs_output_func(
    list_types_syms)

    return get_dyn_or_output_func(
        list_types_syms,
        get_dict_govs_type_output_func())
        
end


function get_govs_dyn_func(
    list_types_syms)

    return get_dyn_or_output_func(
        list_types_syms,
        get_dict_govs_type_dyn_func())
        
end



function get_govs_dyn_func(
    list_types_syms,
    dae_or_ode_type)

    return get_dyn_or_output_func(
        list_types_syms,
        get_dict_govs_type_dyn_func(
            dae_or_ode_type))
        
end


#---------------------------------------------------


function get_avrs_callback_paras_func(
    list_types_syms)

    return get_dyn_or_output_func(
        list_types_syms,
        get_dict_avrs_type_callback_paras_func())
        
end


function get_avrs_init_func(
    list_types_syms)

    return get_dyn_or_output_func(
        list_types_syms,
        get_dict_avrs_type_init_func())
        
end


function get_avrs_output_func(
    list_types_syms)

    return get_dyn_or_output_func(
        list_types_syms,
        get_dict_avrs_type_output_func())
        
end


function get_avrs_dyn_func(
    list_types_syms)

    return get_dyn_or_output_func(
        list_types_syms,
        get_dict_avrs_type_dyn_func())
        
end



function get_avrs_dyn_func(
    list_types_syms,
    dae_or_ode_type)

    return get_dyn_or_output_func(
        list_types_syms,
        get_dict_avrs_type_dyn_func(
            dae_or_ode_type))
        
end


#-----------------------------------------------------
#-----------------------------------------------------


"""

These functions are used to get some selected parameters
of devices from `plant_generators_data_from_json`.

`get_ode_gens_generic_para, get_generic_gens_avr_gov_para`
"""
function get_ode_gens_generic_para(
    plant_generators_data_from_json;
    sequence_order =
        ode_gens_generic_sequence_order,
    selections =
        ode_gens_generic_selections)
    
    ode_gens_generic_para =
         get_selected_comps_ode_para_by_json(
             plant_generators_data_from_json;
             sequence_order =
                 sequence_order,
             selections =
                 selections)

    return namedtuple(
        OrderedDict(
            a_sym => a_value
            for (a_sym, a_value ) in
                zip(selections,
                    ode_gens_generic_para) ) )

end



function get_generic_gens_avr_gov_para(
    plant_generators_data_from_json;
    
    gens_sequence_order =
        ode_gens_generic_sequence_order,
    
    gens_selections =
        ode_gens_generic_selections,
    
    govs_and_avrs_sequence_order =
        govs_and_avrs_sequence_order,
    
    govs_and_avrs_selections =
        govs_and_avrs_selections)

    generic_gens_para =
        get_components_properties_by_json(
            plant_generators_data_from_json;
            sequence_order =
                 gens_sequence_order ,
             selections =
                 gens_selections )
    

    "To make sure Vector{NamedTuple} is returned
     instead of Vector{Any}"
    generic_gens_para =
        NamedTuple[
            item for item in
                generic_gens_para]

    
    (generic_govs_para,
     generic_avrs_para) =
        get_selected_comps_ode_para_by_json(
            plant_generators_data_from_json;
            sequence_order =
                govs_and_avrs_sequence_order ,
            selections =
                govs_and_avrs_selections )
    

    return (;generic_gens_para,
            generic_govs_para,
            generic_avrs_para)
end

# ---------------------------------------------------
# ---------------------------------------------------

"""

This function is used in generating a namedtuple
consisting of data struture needed to simulate a
generator plant. A generator plant can consist of a
generator, gov, avr, etc.

"""
function get_generic_namedtuple_per_plant_para_wt_kwd_para(
    ωref0_vref0_porder0_id_iq_vh;
    kwd_para = plants_kwd_para )

    (state_vars_idx,

     ωref0_vref0_porder0_id_iq_vh_Idx,

     generic_gens_para,
     generic_avrs_para,
     generic_govs_para,

     vec_comp_states_Idx,

     avrs_govs_cb_sw,
     avrs_govs_cb_sw_Idx,
     
    
     comps_dyn_funs,
     comps_output_funs,

    ωs) =
        kwd_para
    
    #----------------------------------------


    ωref0_Idx =
        ωref0_vref0_porder0_id_iq_vh_Idx.ωref0_Idx
    
    vref0_Idx =
        ωref0_vref0_porder0_id_iq_vh_Idx.vref0_Idx
    
    porder0_Idx =
        ωref0_vref0_porder0_id_iq_vh_Idx.porder0_Idx
    
    id_Idx =
        ωref0_vref0_porder0_id_iq_vh_Idx.id_Idx
    
    iq_Idx =
        ωref0_vref0_porder0_id_iq_vh_Idx.iq_Idx
    
    vh_Idx =
        ωref0_vref0_porder0_id_iq_vh_Idx.vh_Idx

    #----------------------------------------
    
    ωref0 =
        ωref0_vref0_porder0_id_iq_vh[
            ωref0_Idx]
    
    vref0 = ωref0_vref0_porder0_id_iq_vh[
        vref0_Idx]
    
    porder0 =
        ωref0_vref0_porder0_id_iq_vh[
            porder0_Idx]
    
    id =
        ωref0_vref0_porder0_id_iq_vh[
            id_Idx]
    
    iq =
        ωref0_vref0_porder0_id_iq_vh[
            iq_Idx]
    
    vh = ωref0_vref0_porder0_id_iq_vh[
        vh_Idx]

    
    #----------------------------------------
                 
    gens_dyn_funs! =
        [an_item.gen_dyn_fun for an_item in
             comps_dyn_funs]

    avrs_dyn_funs! = 
        [an_item.avr_dyn_fun for an_item in
             comps_dyn_funs]

    govs_dyn_funs! = 
        [an_item.gov_dyn_fun for an_item in
             comps_dyn_funs]

    
    #----------------------------------------
             
    gens_output_funs =
        [an_item.gen_output_fun for an_item in
             comps_output_funs]

    avrs_output_funs = 
        [an_item.avr_output_fun for an_item in
             comps_output_funs]

    govs_output_funs = 
        [an_item.gov_output_fun for an_item in
             comps_output_funs]
    
    #----------------------------------------

    per_plant_gov_dyn_fun_sym_name = []
    
    per_plant_generic_model_para = []

    per_plant_generic_model_kwd_para = []

    #----------------------------------------

    for (a_ωref0,
         a_vref0,
         a_porder0,
         a_id,
         a_iq,
         a_vh,
             
         gen_para,
         avr_para,
         gov_para,

         comps_Idx,

         avr_gov_cb_sw,
         avr_gov_cb_sw_Idx,

         gen_dyn_fun!,
         avr_dyn_fun!,
         gov_dyn_fun!,
         
         gen_output_fun,
         avr_output_fun,
         gov_output_fun) in
        zip( 
             ωref0,
             vref0,
             porder0,
             id,
             iq,
             vh,
             
             generic_gens_para,
             generic_avrs_para,
             generic_govs_para,

             vec_comp_states_Idx,

             avrs_govs_cb_sw,
             avrs_govs_cb_sw_Idx,

             gens_dyn_funs!,
             avrs_dyn_funs!,
             govs_dyn_funs!,
         
             gens_output_funs,
             avrs_output_funs,
             govs_output_funs)

        push!(per_plant_generic_model_para,             
                [a_ωref0,
                 a_vref0,
                 a_porder0,
                 a_id,
                 a_iq,
                 a_vh])
                              
        if Symbol(split(String(
                      nameof(gov_dyn_fun!)),"__")[2]) == :nothing
            
            comps_dyn_fun =
                (gen_dyn_fun!,
                 avr_dyn_fun! )
                    
            comps_output_fun =
                (gen_output_fun,
                 avr_output_fun )
            
            plant_kwd_para =
                (;gen_para,
                 avr_para,

                 comps_Idx,

                 avr_gov_cb_sw,
                 avr_gov_cb_sw_Idx,

                 comps_dyn_fun,
                 comps_output_fun,
                 
                  ωs) 

            String(nameof(gov_dyn_fun!))

            # extract symbol :nothing
            push!(per_plant_gov_dyn_fun_sym_name,
                  Symbol(split(String(
                      nameof(gov_dyn_fun!)),"__")[2]) )
            
            
            push!(per_plant_generic_model_kwd_para,
                  plant_kwd_para )
            
        else

            comps_dyn_fun =
                (gen_dyn_fun!,
                 avr_dyn_fun!,
                 gov_dyn_fun! )
         
                    
            comps_output_fun =
                (gen_output_fun,
                 avr_output_fun,
                 gov_output_fun )
            
            plant_kwd_para =
                (;gen_para,
                 avr_para,
                 gov_para,

                 comps_Idx,

                 avr_gov_cb_sw,
                 avr_gov_cb_sw_Idx,
                 

                 comps_dyn_fun,
                 comps_output_fun,
                 
                  ωs) 

            push!(per_plant_gov_dyn_fun_sym_name,
                  nameof(gov_dyn_fun!) )
            
            push!(per_plant_generic_model_kwd_para,
                  plant_kwd_para )
                
        end        
    end

    return (;per_plant_gov_dyn_fun_sym_name,
            per_plant_generic_model_para,
            per_plant_generic_model_kwd_para)

end



function get_generic_per_plant_para_wt_kwd_para(
    ωref0_vref0_porder0_id_iq_vh;
    kwd_para = plants_kwd_para )

    (state_vars_idx,

     ωref0_vref0_porder0_id_iq_vh_Idx,

     generic_gens_para,
     generic_avrs_para,
     generic_govs_para,

     vec_comp_states_Idx,

     avrs_govs_cb_sw,
     avrs_govs_cb_sw_Idx,
     
    
     comps_dyn_funs,
     comps_output_funs,

    ωs) =
        kwd_para
    
    #----------------------------------------


    ωref0_Idx =
        ωref0_vref0_porder0_id_iq_vh_Idx.ωref0_Idx
    
    vref0_Idx =
        ωref0_vref0_porder0_id_iq_vh_Idx.vref0_Idx
    
    porder0_Idx =
        ωref0_vref0_porder0_id_iq_vh_Idx.porder0_Idx
    
    id_Idx =
        ωref0_vref0_porder0_id_iq_vh_Idx.id_Idx
    
    iq_Idx =
        ωref0_vref0_porder0_id_iq_vh_Idx.iq_Idx
    
    vh_Idx =
        ωref0_vref0_porder0_id_iq_vh_Idx.vh_Idx

    #----------------------------------------
    
    ωref0 =
        ωref0_vref0_porder0_id_iq_vh[
            ωref0_Idx]
    
    vref0 = ωref0_vref0_porder0_id_iq_vh[
        vref0_Idx]
    
    porder0 =
        ωref0_vref0_porder0_id_iq_vh[
            porder0_Idx]
    
    id =
        ωref0_vref0_porder0_id_iq_vh[
            id_Idx]
    
    iq =
        ωref0_vref0_porder0_id_iq_vh[
            iq_Idx]
    
    vh = ωref0_vref0_porder0_id_iq_vh[
        vh_Idx]

    
    #----------------------------------------
                 
    gens_dyn_funs! =
        [an_item.gen_dyn_fun for an_item in
             comps_dyn_funs]

    avrs_dyn_funs! = 
        [an_item.avr_dyn_fun for an_item in
             comps_dyn_funs]

    govs_dyn_funs! = 
        [an_item.gov_dyn_fun for an_item in
             comps_dyn_funs]

    
    #----------------------------------------
             
    gens_output_funs =
        [an_item.gen_output_fun for an_item in
             comps_output_funs]

    avrs_output_funs = 
        [an_item.avr_output_fun for an_item in
             comps_output_funs]

    govs_output_funs = 
        [an_item.gov_output_fun for an_item in
             comps_output_funs]
    
    #----------------------------------------
    
    return  [ Symbol(split(String(
                      nameof(gov_dyn_fun!)),"__")[2]) == :nothing ?
        (per_plant_gov_dyn_fun_sym_name =  Symbol(split(String(
                      nameof(gov_dyn_fun!)),"__")[2]) ,
         per_plant_generic_model_para =
        [a_ωref0, a_vref0, a_porder0, a_id, a_iq, a_vh],
         per_plant_generic_model_kwd_para =
             (gen_para, avr_para, comps_Idx,
              avr_gov_cb_sw, avr_gov_cb_sw_Idx,
              ( gen_dyn_fun!, avr_dyn_fun! ),
              ( gen_output_fun, avr_output_fun))) :
                  (per_plant_gov_dyn_fun_sym_name =
                  nameof(gov_dyn_fun!),
                   per_plant_generic_model_para =
                  [a_ωref0, a_vref0, a_porder0,
                   a_id, a_iq, a_vh],
                   per_plant_generic_model_kwd_para =
                       (gen_para, avr_para, gov_para, comps_Idx,
                        avr_gov_cb_sw, avr_gov_cb_sw_Idx,
                        ( gen_dyn_fun!, avr_dyn_fun!,
                          gov_dyn_fun! ),
                        ( gen_output_fun, avr_output_fun,
                          gov_output_fun )))
      for (a_ωref0,
         a_vref0,
         a_porder0,
         a_id,
         a_iq,
         a_vh,
             
         gen_para,
         avr_para,
         gov_para,

         comps_Idx,

         avr_gov_cb_sw,
         avr_gov_cb_sw_Idx,

         gen_dyn_fun!,
         avr_dyn_fun!,
         gov_dyn_fun!,
         
         gen_output_fun,
         avr_output_fun,
         gov_output_fun) in
        zip( 
             ωref0,
             vref0,
             porder0,
             id,
             iq,
             vh,
             
             generic_gens_para,
             generic_avrs_para,
             generic_govs_para,

             vec_comp_states_Idx,

             avrs_govs_cb_sw,
             avrs_govs_cb_sw_Idx,

             gens_dyn_funs!,
             avrs_dyn_funs!,
             govs_dyn_funs!,
         
             gens_output_funs,
             avrs_output_funs,
             govs_output_funs) ]

end

#-----------------------------------------------------

# comment
